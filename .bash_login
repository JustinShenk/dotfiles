clear;pwd;ls

stty werase undef
bind '"\C-w": backward-kill-word'
# bind '"\C-j": unix-word-rubout' # causes iTerm+Go2Shell fuckups

# Lang env variable
export LC_ALL=en_US.UTF-8 # w/o this, can't import e.g. matplotlib? wtf?
export LANG=en_US.UTF-8
#
# Add own shell scripts to path
export PATH=$PATH:$HOME/Documents/Programming/Bash

export PATH=/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11/bin:/usr/texbin:/opt/local/libexec/qt4/bin/:/opt/local/Library/Frameworks/Python.framework/Versions/3.5/bin/:/opt/local/Library/Frameworks/Python.framework/Versions/2.7/bin/:$PATH
# second part
#
# Default env variable $LANG
# LANG=de_DE.UTF-8

# Shortcut for not having to type -a flag always. -F flag for marking
# directories and executables
alias ls='ls -F'


# To simply javadoc generation
alias javadoc='find ./src -name *.java > ./sources_list.txt;javadoc -author -version -d doc @sources_list.txt; rm -f ./sources_list.txt'

export CLASSPATH=/Users/Rasmus/Library/Java/Extensions:.

# Avoid accidental removal, prompt first.
# alias rmi='rm -i'

# ================================================================================ 
# Change command line prompt into a penis with length proportional to the
# distance from root

# repeat char n times (found on SO)
repl() { printf "$1"'%.s' $(eval "echo {1.."$(($2))"}"); } 

# print distance from root. This works only correctly if there is no slash at
# the end of the path given.
depth() {
   if [ "$1" = '/' ]; then 
      echo 1
   else
      echo $(echo "$1/" | grep -o "/" | wc -l)
   fi 
}
export PS1='`date +%H:%M:%S`: \[\e[1;33m\]8`repl 𝌆 $(depth "$(pwd)")`D\[\e[m\]:[\[\e[35m\]\W\[\e[m\]] '
# ================================================================================ 

export TEX=/users/rasmus/documents/latex/texnisches/
export DROPBOX='/Volumes/Macintosh HD/Users/Rasmus/Dropbox'

# Quick login at cs university server
alias ssh-quick="ssh rdiederichse@cip10.informatik.uos.de"

# Include scheme-listings
export TEXINPUTS=/usr/local/texlive/texmf-local/tex/latex/scheme-listings/:$TEXINPUTS
export TEXINPUTS=/usr/local/texlive/texmf-local/tex/latex/atmega-listings/:$TEXINPUTS

export EDITOR=vim
export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx # don't remember what this is for
export CLICOLOR=1

export UNI='/Users/Rasmus/Documents/Uni/Master/Semester 3/'

# Cheesus christ, why does pkg-config not know its own fckng standard directory,
# what the actual fuck.
PKG_CONFIG_PATH=/opt/local/lib/pkgconfig:$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig
export PKG_CONFIG_PATH

# Change to current Finder directory
cdf() {
    target=`osascript -e 'tell application "Finder" to if (count of Finder windows) > 0 then get POSIX path of (target of front Finder window as text)'`
    if [ "$target" != "" ]; then
        cd "$target"; pwd
    else
        echo 'No Finder window found' >&2
    fi
}

# export PYTHONPATH=/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/:/usr/local/lib/python2.7/site-packages:/Library/Python/2.7/site-packages:$PYTHONPATH

alias make='make -j4'
alias la='ls -a'

export PATH=$PATH:~/Library/Python/2.7/bin/

eval "$(thefuck --alias)"
# You can use whatever you want as an alias, like for Mondays:
eval "$(thefuck --alias FUCK)"

# iTerm shell integration
source ~/.iterm2_shell_integration.`basename $SHELL`

# Add packagize to PATH 
export PATH=$PATH:~/Documents/Programming/Ruby/packagize

# bash-completion
if [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then
    . /opt/local/etc/profile.d/bash_completion.sh
fi

alias vi='vim'
alias pytest='py.test'

# enable ctrl-s
stty -ixon

# dedup history
export HISTCONTROL=ignoreboth:erasedups
export MPLBACKEND="module://itermplot"

alias cat='lolcat'

################################################################################
#                       Stuff from mrzool/bash-sensible                        #
################################################################################
# Unique Bash version check
if ((BASH_VERSINFO[0] < 4))
then 
  echo "sensible.bash: Looks like you're running an older version of Bash." 
  echo "sensible.bash: You need at least bash-4.0 or some options will not work correctly." 
  echo "sensible.bash: Keep your software up-to-date!"
fi

# Prevent file overwrite on stdout redirection
# Use `>|` to force redirection to an existing file
set -o noclobber

# Automatically trim long paths in the prompt (requires Bash 4.x)
PROMPT_DIRTRIM=2
# 
# Case-insensitive globbing (used in pathname expansion)
shopt -s nocaseglob;

# Perform file completion in a case insensitive fashion
bind "set completion-ignore-case on"

# Display matches for ambiguous patterns at first tab press
bind "set show-all-if-ambiguous on"

# Immediately add a trailing slash when autocompleting symlinks to directories
bind "set mark-symlinked-directories on"

# Append to the history file, don't overwrite it
shopt -s histappend

# Save multi-line commands as one command
shopt -s cmdhist

# Record each line as it gets issued
PROMPT_COMMAND='history -a'

# Huge history. Doesn't appear to slow things down, so why not?
HISTSIZE=500000
HISTFILESIZE=100000

# Avoid duplicate entries
HISTCONTROL="erasedups:ignoreboth"

## BETTER DIRECTORY NAVIGATION ##

# Prepend cd to directory names automatically
shopt -s autocd 2> /dev/null
# Correct spelling errors during tab-completion
shopt -s dirspell 2> /dev/null
# Correct spelling errors in arguments supplied to cd
shopt -s cdspell 2> /dev/null

# This defines where cd looks for targets
# Add the directories you want to have fast access to, separated by colon
# Ex: CDPATH=".:~:~/projects" will look for targets in the current working directory, in home and in the ~/projects folder
CDPATH="."
